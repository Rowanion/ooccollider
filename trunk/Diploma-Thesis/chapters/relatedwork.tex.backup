\chapter{Verwandte Arbeiten}
\label{relatedwork}

\begin{itemize}
 \item 1-2 Paper pro Thema sollte reichen
 \item für die Bibliographie: auch Info-Fachbücher zitieren für die Datenstrukturen z.B.
\end{itemize}

An dieser Stelle möche ich einige Veröffentlichungen vorstellen, welche sich mit ähnlichen Problemstellungen befassen, wie die vorliegende Arbeit.
\section{Paralleles Rendering}
Beim parallelen Rendering geht es um die Verteilung von Aufgaben in einer Netzwerktopologie. Dies kann entweder durch einfaches Multithreading oder durch einen Rechnervebund (Cluster) geschehen. Dabei wird meist entweder das Rendern selber in verschiedene Unteraufgaben geteilt. Eine weitere Möglichkeit ist auch die Trennung von Aufgaben, die im Eigentlichen nichts miteinander zu tun haben, wie zum Beispiel Trennung der Daten-Verwaltung von der Bilderzeugung.\\*
In den letzten Jahren wurden viele Möglichkeiten zur Verteilung der Aufgaben in parallelen Rendersystemen veröffentlicht. Molnar et al.\cite{molnar} klassifizieren Parallelisierungsstrategien in drei Kategorien, in Abhängigkeit davon, an welcher Stelle der Rendering-Pipeline Polygone nach ihrer Sichtbarkeit sortiert werden.\linebreak\linebreak
Sort-First-Algorithmen teilen den Bildschirm in disjunkte Regionen ein (Kacheln) und weisen jedem Renderer eine solche Kachel zu. Jeder Render ist für die gesamte Bilderzeugung in diesem einem Bildabschnitt zuständig. Geometrische Objekte werden zu den Renderer übertragen, wenn diese in der jeweiligen Kachel sichtbar sind. Sort-First-Renderer nutzen die Frame-to-Frame Kohärenz gut aus, da nur wenige geometrische Primitive zwischen einzelnen Frames die Bildausschnitte wechseln. Die Rendering-Algorithmen sind bei Sort-First frei wählbar, da jeder Renderer die vollständige Geometrie für seine Kachel besitzen muss. Allerdings kann es sein, dass sich viele geometrische Objekte der gesamten Szene auf wenige Kacheln verteilen, wodurch die Lastverteilung aus dem Gleichgewicht gerät. Ein weiterer Nachteil ist, dass Objekte von mehrern Render gezeichnet werden müssen.\linebreak\linebreak
Sort-Middle-Algorithmen\linebreak
bla\linebreak\linebreak
Sort-Last-Algorithmen\linebreak Objekte
bla\linebreak\linebreak
\textbf{Jeweils kurze Einleitung was das ist}\\*
\cite{samanta}: \textit{Hybrid sort-first and sort-last parallel rendering with a cluster of pcs}
\begin{itemize}
 \item Mischung aus Sort-first und sort-last im cluster
 \item 64 PCs im Cluster
 \item Komposition des finalen Bildes erfolgt mittels peer-to-peer Pixel verteilung
 \item Objekte werden gruppiert nach ihrer minimalen BoundingBoxüberlappung. Danach erfolgt ihre Verteilung auf verschiedenen Sort-Last Knoten.
 \item Die Tiefenwerte werden dann über das Netzwerk zu anderen Servern geschickt, welche überlappende Teile besitzen. Diese schreiben nun ihren Tiefenbuffer mittels Tiefenvergleich um ein möglichst vollständiges Tiefenbild zu erhalten.
 \item Am Ende schicken alle ihre Farbpixel an den Kachelrenderer, welche lediglich die entstandenen Bildkacheln zusammen setzt.
 \item Vorteil dieser P2P-Herangehensweise: geringere Latenzen und verbesserete Netzlastnutzung.
 \item 550MHz P3 client, 8x500MHz P3 server mit 256MB RAM und Geforce 256 GPUs.
\end{itemize}

\cite{abraham}: \textit{A load-balancing strategy for sort-first distributed rendering}
\begin{itemize}
 \item Multi-Threaded, Sort-First, prallel
 \item kein Out-Of-Core
 \item benutzt Tiling
 \item Bestimmung der Renderknotenbelastung anhand der letztenn Renderzeit
 \item Modell wird auf allen Renderknoten vorgehalten
 \item Multi-Threading: ein Thread rendert während ein Anderer für den Empfang und Versand von Nachrichten zuständig ist
 \item Der schnellste Knoten einer Runde bekomt in der nächsten Runde diejenige Kachel mit dem größten Aufwand.
 \item das Kacheltauschen ist für Out-Of-Core ungeeignet und erfordert eine homogene Clusterkonfiguration.
 \item 10-Knoten-Netzwerk mit P4, 512MB Ram und GeForce 4, angebunden via GigaBit Ethernet
\end{itemize}

\cite{baxter}: \textit{Gigawalk: interactive walkthrough of complex environments}
\begin{itemize}
 \item - Paralleler Algorithmus mit Occlusion Culling und LOD
 \item Benutzt räumliche Clusterung und Lastbalancierung
 \item Berechnung der LOD im Preprozessing; Potentially Visible Sets zur Laufzeit durch FrustumCullung und hierarchical Z-Buffer OcclusionCulling
 \item Benutzt keine Octrees zur Clusterung sondern Minimale Spannbäume um die minimale Ausdehnung eines Cluster zu brechnen um 2 Cluster miteinander verbinden zu können.
 \item Hierarchie wird erzeugt durch Axis-Aligned BoundingBoxes über die o.g. Cluster wodurch sich ein Szene-Graph ergibt.
 \item Aus dem Szene-Graph werden Levels-Of-Detail erzeugt und als hierarchische Occluder verwendet
 \item \textbf{Pixel-Fehler -> Image-vergleich}
 \item SGI Onyx Workstations, 300MHz, R12000 mit Infinite Reality Grafikboards, 16Gb Ram, 3 CPUs, 2 Grafik-Pipelines
 \item Getestet mit bis zu 82 Millionen Dreiecken
 \item 11-50FPS
 \item Kommunikation über SharedMemory Queues
\end{itemize}

\cite{dpbp}: \textit{dpdb: a sort-first parallel rendering algorithm for distributed rendering environments}
\begin{itemize}
 \item recursive sort-first partitioning
 \item Dynamic Pixel Bucket Partition (DPBP)
 \item flexible Netzwerkumgebung, aka Multi-Cluster, Instituts-Grenzen übergreifend
 \item Benutzt tiled-rendering
 \item \textbf{im Paper bei RelWorks steht einleitung zu sort-first, sort-middle, sort-last!!}
 \item Preprozessing: räumliche Aufteile anhand von Gewichtung in Form von Dreiecküberlagerungen im ScreenSpace (clustering)
 \item Danacher deren die projizierten Boundingboxen in Pixel Buckets sortiert. Teile der Boxen, die au dem Bild herausragen werden weg geclippt.
\end{itemize}

\cite{DBLP:journals/ijvr/YinJSZ06}: \textit{Multi-screen Tiled Displayed, Parallel Rendering System for a Large Terrain Dataset}
\begin{itemize}
 \item Sort-First, Out-Of-Core, tiled Display im PC-Cluster
 \item Verwendet Out-Of-Core LODs
 \item Preprozessing: Terrain-Daten im Quadtree organisiert und auf Platte gespeichert
 \item Intel Xeon, 1Gb RAM, Geforce Fx 5950 * 32 Knoten; GigaBit Ethernet
 \item Quadtree als LOD: Wurzel als grobe Auflösung und Blattknoten in der höchsten Auflösung
 \item Frustum-Culling only, da Terraindaten nicht sehr komplex in der Tiefe sind
 \item Focus auf kalibrierung der einzelnen Beamer durch alpfa-blending an den Kanten der einzelnen Beamer-Bilder
\end{itemize}

\section{Out-of-core Rendering}
\textbf{Jeweils kurze Einleitung was das ist}\\*
\cite{manocha}: \textit{Out of core rendering in massive geometric environments}
\begin{itemize}
 \item Out-of-Core, Scene-Grapth, diverses Culling
 \item verwendet Prefetching mit LOD-Switching
 \item statische LODs werden vorberechnet
 \item 2 Prozesse: einer render und cullt und der andere kümmert sich um Prefetching und Disk I/O
 \item Nimmt Darstellungsfehler in Kauf, durch noch nicht geladene, jedoch angeforderte Objekte
 \item Vergrößertes Frustum fürs PreCaching. Größ ändert sich dynamisch mit Bewegungsgeschwindigkeit.
 \item Zusätzlich werden Objeke, die nur im erweiterten Frustum liegen durch ihren Blickwinkel priorisiert. D.h. Objekte die näher am Zentrum der Kamera liegen werden bevorzugt.
 \item Ein weiteres Maß für Priorität liefert die Klassifizierung von Objekten durch deren Screen-Space Error
 \item SGI Workstation, 195Mhz, MXI graphics board, 128MB Ram und einer SGI Onyx mit mehreren 500Mhz Prozessoren und Infinite Reality 3 graphics pipelines und 16GB Ram
\end{itemize}

\cite{gao}: \textit{Efficient view-dependent out-of-core rendering of large scale and complex scenes.}
\begin{itemize}
 \item out-of-core
 \item Partitionierung der Szene in Hierarchie und Hierarchical level-of-detail (HLOD)
 \item Multi-Threaded: render-thread und prefretching-thread
 \item rendering: Hierarchie für grobe Geometrie-AUflösung und HLOD für feine Auflösung im Lokalen.
 \item Preprozessing: Rekursive räumliche Aufteilung des Modells aufgrund von Objektgrößen (Ausdehnung) und begrenzter Dreiecksanzahl.
 \item Das Preprozessing arbeitet Out-of-core, da immer nur ein Objekt angefasst wird
 \item Rendering auch out-of-core
 \item LRU als Cache-Verdrängungsstrategie
 \item avg framerate 13fps
 \item FrustumCulling aber kein OcclusionCulling
\end{itemize}

\cite{wagner1}: \textit{out-of-core sort-first parallel rendering for cluster-based tiled displays}
\begin{itemize}
 \item Sort-first, out-of-core und parallel
 \item Cluster von 16 PCs mit je 512MB RAM
 \item ist eine parallele Erweiterung von iWalk
 \item System ist speziell für High-Res Bilder(4096x3072) gedacht
 \item Hierarchische Representation des Modells auf Platte
 \item \textbf{Paper enthält sehr dateilierte Beschreibung der Sorts von Molnar[4.2]}
 \item Algorithmus benutzt ein Verfahren zur bestimmung sichbarer Geometrie unter Einhalötung eines Kontingents (Dreiecke oder Speichergröße) [PLP]
 \item Wie so viele Systeme verlässt sich auch dieses auf gegebene Bildähnlichkeiten zwischen 2 Frames
\end{itemize}

\cite{wagner2}: \textit{Visibility-based pre-fetching for interactive out-of-core rendering.}
\begin{itemize}
 \item Out-of-core
 \item 13 Million Dreiecke interaktiv
 \item Basiert auf iWalk
 \item räumliche Unterteilung auf Platte
 \item geocache läuft als separater Thread. Von der aktuellen Kamerposition wird festgestellt, welche Geometrie demnächst benötigt werden könnte. Sollte der Geocache mit Ladevorgängen den aktuellen Frame betreffend beschäftigt sein, werden Prefetching-Requests ignoriert.
 \item benutzt prioritized-layered projection (PLP) um Menge der sichtbaren Octree-Knoten zu bestimmen.
 \item Weiterer Vorteil von PLP entsteht durch Erzeugung der hirarchischen Struktur zur Preprozessing-Zeit. Damit ist eine Bestimmung des visual sets ohne Zugriff auf tatsächliche Szenen-Geometrie möglich.
 \item LRU wird als Verdrängungsstrategie genutzt
 \item Durchschnittlich 10fps auf einem Pentium4
\end{itemize}

\cite{wald}: \textit{An Interactive Out-of-Core Rendering Framework for Visualizing Massively Complex Models.}
\begin{itemize}
 \item Out-of-core
 \item benutzt auch raytracing
 \item Verwendet Geometrie-Proxies um das ganze Modell auf einem PC zu rendern.
 \item Hat auch die Boeing 777 gerendert
 \item Dual-Core 1.8GHz Operton mit 6GB RAM
 \item Neues Speichermamangement via memory-mapped I/O (mmap())
 \item Preprozessing erzeugt binäre Daten aus dem Modell um schreibt diese auf Platt für mmap.
 \item System übernimmt die Verwaltung welche Speicherseiten in Hauptspeicher liegen. DUrch Systemaufrufe kann dem Kernel gesagt werden, ob er Seiten auslagern soll oder eher länger im Haupstpeicher belassen soll.
 \item Dieses recht aufwenidige Verfahren ist notwendig da Raytracing benutzt wird, was bei häufigen PageFaults an Interaktivität einbüßt.
 \item Decaching: zyklisch geht ein Thread alle Speicherkacheln durch und setzt das uesed-bit auf null. Sollte die Kachel doch in naher Zukunft benötigt werden, wird das Bit vom Renderer resetet. Findet Thread allerdings eine Kachel bei der use-bit bereits auf 0 gesetzt ist, wird die Kachel aus dem Speicher entfernt.
 \item Geometrie-Proxies werden vom Raytracer apriori gesampelt. SOllte ein Raytracer an Stelle kommen wo eine Speicherseite nicht verfügbar ist, wird die Speicheradresse des benötigten Teils als Schlüssel für eine stl-map verwendet um so an den entsprechenden Proxie zu gelangen.
 \item bei 640x480 3-7 fps
\end{itemize}

\section{Randomized Sample Tree}
Jeweils kurze Einleitung was das ist\\*
sampletree: \cite{klein}: \textit{The randomized sample tree: a data structure for interactive walkthroughs in externally stored virtual environments}\\*

\section{c-Collision Protokoll}
Jeweils kurze Einleitung was das ist\\*
c-Collision?: \cite{DBLP:conf/arcs/RehbergS99}: \textit{Almost optimal schedules with a simple protocol}
\begin{itemize}
 \item -
\end{itemize}



%  ----------------------------------------------------------------------------
%
%       Copyright (for the thesis) 2009 by [author - insert yourself]
%
%       This thesis is published under the
%       Creative Commons Attribution-No Derivative Works 3.0 Austria License
%       as detailed at http://creativecommons.org/licenses/by-nd/3.0/at/
%
%  ----------------------------------------------------------------------------
%  Template credits and license:
%  ----------------------------------------------------------------------------
%
%       "Fakultät für Informatik" diploma/master thesis template 2008
%
%       based upon "Diploma thesis template 2005" by lukas.silberbauer(at)gmx.at
%       based upon "Diplomarbeit mit LaTeX" by Tobias Erbsland
%       incorporating a title page by Informatik-Forum user "Baby"
%       polished and ported to the TU fonts package by Jakob Petsovits
%
%       published under the terms of
%
%  ----------------------------------------------------------------------------
%  "THE BEER-WARE LICENSE":
%  <lukas.silberbauer(at)gmx.at> wrote this file. As long as you retain this
%  notice you can do whatever you want with this stuff. If we meet some day,
%  and you think this stuff is worth it, you can buy me (us) a beer in return.
%  ----------------------------------------------------------------------------
%
%  (end of template credits)
%

\chapter{Einleitung}
\todo[size=\small, color=yellow!40, inline]{Needs Non-Tim understanding}%
\todo[size=\small, color=yellow!40, inline]{Needs Human proofreading}%

Die Leistung von modernen Grafikkarten steigt stetig an. Nur so ist es möglich, immer komplexere 3D-Szenen darzustellen. Aber gerade im Bereich des Computer Aided Designs (CAD) entstehen komplexe 3D-Modelle, welche auch moderne Grafikkarten vor große Herausforderungen stellen. Diese Szenen passen meist nicht in den Speicher von Grafikkarten. Es gibt spezielle Grafik-Workstations mit Shared-Memory und mehreren synchronisierten Grafik-Pipelines, welche allerdings sehr teuer sind. Ein hybrider Verbund von mehreren PCs, ein sogenannter Cluster, bietet eine vergleichsweise preiswerte Möglichkeit, diesen Problemen zu begegnen. Ein Rechnerverbund, bei dem man Einfluss auf einzelne Komponenten hat, ist besser skalierbar als eine Workstation.\\
Ein hybrider Cluster besteht aus einigen Rechnern mit leistungsstarken Grafikkarten und mehreren Rechner mit schwachen Grafikkarten. Die Herausforderung in einem hybriden Cluster besteht darin, die Aufgaben eines Rendering-Systems so zu verteilen, dass jeder Rechner die Aufgaben bewältigt, denen er aufgrund seiner Hardware-Konfiguration am besten gewachsen ist. Dabei ist zu beachten, dass die Rechnenknoten einen beschränkten Arbeitsspeicher besitzen. Das hat zur Folge, dass eine große 3D-Szene unter Beachtung dieser Grenzen aufgeteilt werden muss. Weiterhin impliziert dies, dass kein Render im Besitz der vollständigen Szene ist. Durch die Verteilung einer großen Szene auf mehrere PCs benötigt man somit eine Strategie, um einzelne Bilder rendern zu können. Die Datenmenge, die über das Netzwerk übertragen wird, muss an die vorhandene Infrastruktur angepasst werden, damit das Netzwerk nicht ständig saturiert. Außerdem gilt es, ein geeignetes Datenformat für die 3D-Szene zu finden, was zum Einen den Ladevorgang der Daten verkürzt und zum Anderen den Transport der Daten im Netzwerk ermöglicht.

In dieser Arbeit wurde sich der Aufgabe gestellt, ein paralleles Out-Of-Core Rendering-System zu entwickeln, mit dem große 3D-Modelle auf einem PC-Cluster gerendert werden können. Als Test-Szene wurde das Modell einer Boeing 777\footnote{Das 3D-Modell der Boeing 777 (ca. 350 Millionen Dreiecke, 10 GiB) wurde freundlicherweise von \textit{The Boeing Company}, Seattle, WA, USA zur Verfügung gestellt.} gewählt. Da Modelle dieser Größenordnung weder in den Speicher von Consumer-Grafikkarten, noch in den System-Speicher passen, wurde nach einer guten Verteilung der Daten im Netzwerk gesucht. Mehrere Renderknoten fordern benötigte geometrische Objekte von Datenknoten an und rendern einen Bildausschnitt des finalen Bildes. Um zu verhindern, dass Datenknoten durch große Anfragenmengen überlastet werden, wurde das $c$-Collision Protokoll als gewichteter Datenbalancierer eingesetzt. Ziel dieser Arbeit ist es, die Tauglichkeit des $c$-Collision Protokolls als Lastbalancierer in so einem Rendering-System zu untersuchen. Im Zuge dessen wurden auf dem hier entwickelten System verschiedene Tests durchgeführt. Jeder Test wurde auf unterschiedlichen Systemkonfigurationen durchgeführt, was bedeutet, dass die Anzahl an Renderern, Datenknoten und Redundanzen des Modells entsprechend geändert wurde. Bei einem Test wurden die Bilder pro Sekunde aufgezeichnet, die bei einem Walkthrough\footnote{Ein Walkthrough bezeichnet hier eine Navigation durch eine 3D-Szene, bei der möglichst viele signifikante Stellen des Modells besucht werden.} durch die Szene gemessen werden konnten. Ein weiterer Test bestand darin, an festen Kamerapositionen die zum Neuladen der Szene erforderliche Zeit zu messen. Im letzten Test wurde die durch das $c$-Collision Protokoll verteilte Anfragenlast im Netzwerk überprüft.


%
% EOF
%

%  ----------------------------------------------------------------------------
%
%       Copyright (for the thesis) 2009 by [author - insert yourself]
%
%       This thesis is published under the
%       Creative Commons Attribution-No Derivative Works 3.0 Austria License
%       as detailed at http://creativecommons.org/licenses/by-nd/3.0/at/
%
%  ----------------------------------------------------------------------------
%  Template credits and license:
%  ----------------------------------------------------------------------------
%
%       "Fakultät für Informatik" diploma/master thesis template 2008
%
%       based upon "Diploma thesis template 2005" by lukas.silberbauer(at)gmx.at
%       based upon "Diplomarbeit mit LaTeX" by Tobias Erbsland
%       incorporating a title page by Informatik-Forum user "Baby"
%       polished and ported to the TU fonts package by Jakob Petsovits
%
%       published under the terms of
%
%  ----------------------------------------------------------------------------
%  "THE BEER-WARE LICENSE":
%  <lukas.silberbauer(at)gmx.at> wrote this file. As long as you retain this
%  notice you can do whatever you want with this stuff. If we meet some day,
%  and you think this stuff is worth it, you can buy me (us) a beer in return.
%  ----------------------------------------------------------------------------
%
%  (end of template credits)
%

\chapter{Fazit und Ausblick}
\label{conclusion}
\todo[size=\small, color=yellow!40, inline]{Needs Non-Tim understanding}%
\todo[size=\small, color=yellow!40, inline]{Needs Human proofreading}%

In dieser Arbeit wurde ein eigenständiger paralleler Out-Of-Core Renderer entwickelt, der in der Lage ist, große 3D-Modelle in einem Cluster von PCs rendern zu können. Positive Ergebnisse konnten mit dem Modell einer Boeing 777 als Test-Szene erzielt werden. Das $c$-Collision Protokoll wurde auf seine Tauglichkeit als gewichteter Datenbalancierer in diesem Rendering-System untersucht. \\
In den hier durchgeführten Tests (siehe Kapitel \ref{chap:eval}) hat sich gezeigt, dass das $c$-Collision Protokoll bei einer hinreichend großen Menge an Anfragen für eine gute Balancierung im Netzwerk sorgt. Mit steigender Menge an Redundanzen und Datenknoten kann die Qualität der Balancierung noch verbessert werden. Die Balancierung hatte in den Tests jedoch keine Auswirkung auf die Rendergeschwindigkeit. Im hier entwickelten System spielt die Bandbreite des zugrunde liegenden Netzwerks eine entscheidende Rolle, da das System zur Berechnung jedes Frames eine große Menge an Daten transportieren muss. Es hat sich gezeigt, dass das Netzwerk sehr schnell saturiert und die volle Bandbreite ausgenutzt wird. \\
Da die Test-Szene eine hohen Grad an geometrischer Komplexität besitzt, waren die Grafikkarten in den Rechenknoten bei der Erfüllung der an sie gerichteten Aufträge überlastet. Das betrifft zum Einen den Speicherbedarf der Szene und zum Anderen die Menge an kleinen Dreiecken, die jeden Frame auf Sichtbarkeit überprüft werden müssen. Eine gute Datenbalancierung ist somit kein hinreichender Ausgleich für leistungsschwächere Hardware, um bessere Rendering-Zeiten zu erzielen. 

Um das System dennoch zu verbessern, könnte man versuchen, vor dem Versand von Bildern, Objekten und Tiefenbuffern eine Datenkompression zu verwenden, um die benötigte Netzwerkbandbreite zu reduzieren. Eine weitere Verbesserungsmöglichkeit besteht darin, genauere Bounding-Volumes einzusetzen, als dies bei Boxen der Fall ist. Diese Approximationen sollten allerdings zeitlich unaufwendig sein. Die Bounding-Volumes könnten dann beim Occlusion-Culling benutzt werden, um in schneller Zeit genauere Ergebnisse zu erzielen. Die Verwendung eines zusätzlichen Level-of-Details ist ebenso denkbar, um die Menge an Dreiecken pro Renderknoten möglichst gering zu halten. Weiterhin ist eine Leistungssteigerung denkbar, indem die maximale Tiefe des verwendeten Octrees reduziert würde. Die Belegung der Blattknoten im hier verwendeten Baum liegt im Schnitt bei ca. 1000 Dreiecken. Das ist sehr wenig im Hinblick auf die Leistungsfähigkeit von aktueller Grafikhardware. Denkbar ist auch, dass die Verteilung von Dreiecken im Octree nicht unbedingt von Vorteil ist, da die im Modell vorhandenen Dreiecke in der Regel sehr klein sind. Würde man die Objektgruppen, wie sie im ursprünglichen Modell vorhanden sind, nicht weiter unterteilen, könnte dies einen Performanzgewinn gegenüber der Verteilung auf Basis von Dreiecken liefert. Durch das Unterteilen von Objekten werden räumliche Zusammenhangskomponenten aufgebrochen, was zu einer Zerstörung des Vertex-Caches führt. Bleiben die ursprünglichen Objekte erhalten, können die Hardware-Features der Grafikkarte besser genutzt werden.

%
% EOF
%


\chapter{Implementierung}
\label{chap:impl}
Kapiteleinleitung\\*
Ankündigung des Bedarfs an günstigen Approximationen für Backend-Knoten -> Verweis auf Clemens\\
C++, OpenGL, STL, usw.
Probleme / Herausforderungen in die Unterpunkte ziehen\\
Probleme:\\
Speicherfragmentierung\\
Liste mit Objekten zu lang\\
Per-Frame-Verwaltung der List sehr aufwendig $\rightarrow$ Verkürzung der Liste bringt viel
\begin{itemize}
 \item Speicherverwaltung
 \item Preprozessing
 \item From Scratch entwickelt / keine Erweiterung eines bestehenden Systems
 \item Filesystem
\end{itemize}

\section{Preprocessing}
\label{sec:impl:preprocessing}
Das Modell der Boeing 777 liegt im OBJ-Format\footnote{Ein freies nicht-binäres Dateiformat zur Beschreibung von Geometrie. Siehe \cite{obj}. } vor. Eine Textdatei zu parsen und zu laden ist wesentlich langsamer als dieselben Daten binär auszulesen, da die Daten erst von Text in Zahlen konvertiert werden müssen. Räumliche Datenstrukturen sind ebenfalls nicht vorhanden. Aus diesem Grund ist es notwendig, diese 3D-Szene zuvor in ein Format zu übertragen, welches einfcaher und schneller zu handhaben ist. Viele Rendering-Systeme bauen Datenstrukturen wie Octrees beim Programmstart ad-hoc auf. Das ist im Falle der Boeing nicht praktikabel, da das Modell nicht in den Speicher passt.
\cite{obj}\\
\todo[size=\small, color=blue!40, inline]{Unterkapitel Preprocessing}%
\begin{itemize}
 \item Aufbereitung der Model-Daten in ein verständliches Format
 \item Akkumulierte Preprocessingzeiten \& und grobe Rechnerkonfiguration
\end{itemize}

\section{Datenstruktur}
\label{sec:impl:datenstruktur}
\todo[size=\small, color=blue!40, inline]{Unterkapitel Datenstruktur}%
\begin{itemize}
 \item Verewigt auf HDD -> begründen warum
 \begin{itemize}
  \item Modell passt nicht in Speicher -> im PreProc \ref{sec:impl:preprocessing} musste immer ein Knoten nach dem anderen angefasst werden.
 \end{itemize}

 \item Teilung von Skeleton \& tatsächlichen geometrischen Daten
\end{itemize}

\section{Programm}
\label{sec:impl:program}
\label{masternode}
MasterNode:
\begin{itemize}
 \item verschicke Kameraposition und Tasteneingabe
 \item warte auf Objektanfragen von allen RenderNodes
 \item führe c-Collision Protokoll auf diesen aus, gebündelt zu Anfrangen der Menge an DataNodes
 \item sende die Anfragen an die ausgewählten DataNodes weiter
 \item warte auf Kacheln von allen RenderNodes
\end{itemize}

\label{rendernode}
RenderNode:
\begin{itemize}
 \item warte auf Tasteneingaben und Kameraposition
 \item Erweitere das Frustum und parse den Octree/Sampletree
 \item Jeder Knoten im Frustum bekommt einen Zeitstempel
 \item sollte ein Knoten schon länger online oder offline sein, tagge den Knoten für eine erneute Überbprüfung.
 \item schicke Anfragen über fehlende Objekte an den MasterNode
 \item Rendere eine Kachel mit allen verfügbaren Knoten, die online sind.
 \item Beginne Empfang aller anstehenden Knoten.
 \item verschicke die Kachel an den MasterNode
\end{itemize}

\label{datanode}
DataNode:
\begin{itemize}
 \item warte auf irgendeine ankommende Nachricht
 \item Ist es ein Request, sortiere die Requests nach RenderNode und beginne mit den Occlusion-Tests
 \item Bei erfolgreichen Tests wird das Objekt vollständig in den Tiefenbuffer gerendert
 \item Verschicke alle positiv getesteten Objekte an die anfordernden RenderNodes
 \item Ist es ein Tiefenbuffer, schreibe den Buffer für den jeweiligen RenderNode in den FrameBuffer
\end{itemize}


\section{Netzwerkarchitektur}
\label{sec:impl:netzwerkarchitektur}
\todo[size=\small, color=blue!40, inline]{Unterkapitel Netzwerkarchitektur}%
Hardwarebeschaffenheit und die NodeTypen

\section{Kommunikation}
\label{sec:impl:kommunikation}
\todo[size=\small, color=blue!40, inline]{Unterkapitel Kommunikation}%
Sequenzdiagramm \ref{fig:impl:seqdiagrender}, \ref{fig:impl:seqdiagdepth}

\begin{figure}
\input{plots/seq_diag_render.tex}
  \caption{Sequenzdiagramm: Kommunikation für die Render-Schleife}
  \label{fig:impl:seqdiagrender}
\end{figure}

\begin{figure}
\input{plots/seq_diag_depth.tex}
  \caption{Sequenzdiagramm: Kommunikation für ein Tiefenbuffer-Update}
  \label{fig:impl:seqdiagdepth}
\end{figure}

\section{Rendering-Algorithmus}
\label{sec:impl:renderalgo}
\todo[size=\small, color=blue!40, inline]{Unterkapitel Rendering-Algorithmus}%
\begin{itemize}
 \item wie wird gerendert?
 \item wo kriegen die ihre Daten her?
 \item wird die Last balanciert
\end{itemize}


%
% EOF
%
